#include "quantum.h"
#include "rgblight.h"
#include <stdio.h> 
#include <stdlib.h>


#ifdef ENCODER_ENABLE
bool encoder_update_kb(uint8_t index, bool clockwise) {
    if (!encoder_update_user(index, clockwise)) { return false; }
    if (index == 0) {
        if (clockwise) {
            tap_code(KC_PGDN);
        } else {
            tap_code(KC_PGUP);
        }
    } else if (index == 1) {
        if (clockwise) {
            tap_code_delay(KC_VOLD, 10);
        } else {
            tap_code_delay(KC_VOLU, 10);
        }
    }
    return true;
}
#endif


#ifdef OLED_ENABLE
oled_rotation_t oled_init_kb(oled_rotation_t rotation) {
    if (/*!*/is_keyboard_left()) {
        return OLED_ROTATION_180;
    }

    return rotation;
}

void oled_render_boot(bool bootloader) {
    oled_clear();
    oled_set_cursor(0, 1);
    if (bootloader) {
        oled_write_P(PSTR("Awaiting new firmware..."), false);
    } else {
        oled_write_P(PSTR("Rebooting..."), false);
    }

    oled_render_dirty(true);
}

char* int_to_str(long int value) {
    int length = snprintf(NULL, 0, "%ld", value);
    char* str = malloc(length + 1);
    snprintf(str, length + 1, "%ld", value);
    return str;
}

static const char PROGMEM uwu[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x3F, 0x7C, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xE0, 0xF8, 0x7F, 0x3F, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x3E, 0x78, 0xE0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xE0, 0xF8, 0x7E, 0x3F, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x08, 0x80, 0x12, 0x40, 0x04, 0x91, 0x00, 0x24, 0x81, 0x08, 0x22, 0x80, 0x08, 0x20, 0x00, 0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0xFE, 0xE0, 0x80, 0x00, 0x80, 0xC0, 0xE0, 0xE0, 0xC0, 0x80, 0x80, 0xE0, 0xFC, 0x7E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x80, 0x20, 0x04, 0x10, 0x42, 0x08, 0x21, 0x84, 0x10, 0x01, 0x24, 0x80, 0x09, 0x20, 0x04, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x02, 0x10, 0x00, 0x22, 0x08, 0x00, 0x22, 0x08, 0x00, 0x12, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x10, 0x04, 0x01, 0x10, 0x04, 0x00, 0x11, 0x04, 0x00, 0x08, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

typedef union {
  uint32_t raw;
  struct {
    long int counter :32;
  };
} config_t;

config_t config;

bool debug = false;
int frame_counter = 0;
long int counter = 0;

bool oled_task_kb(void) {
    if (!oled_task_user()) {
        return false;
    }

    int offset = -4;
    long int tmp = counter;
    while (tmp >= 10) {
        tmp /= 10;
        offset++;
    }
    if (offset < 0) {
        offset = 0;
    }
    oled_set_cursor(offset, 0);
    //oled_write_P(PSTR("UwU\n"), false);
    if (!debug) oled_write_raw_P(uwu, sizeof(uwu));

    oled_set_cursor(0, 0);
    char* str = int_to_str(counter);
    oled_write(str, false);
    free(str);

    frame_counter++;
    if (frame_counter == 20) { // 20 fps
        frame_counter = 0;
        if (counter != config.counter) {
            config.counter = counter;
            eeconfig_update_user(config.raw);
            oled_set_cursor(0, 3);
            oled_write_P(PSTR("svd"), false);
        }
    }
    if (!debug) {
    } else if (is_keyboard_left()) {
        if (offset == 0) {
            oled_set_cursor(17, 0);
        } else {
            oled_set_cursor(0, 1);
        }
        oled_write_P(PSTR("left"), false);
    } else {
        if (offset == 0) {
            oled_set_cursor(16, 0);
        } else {
            oled_set_cursor(0, 1);
        }
        oled_write_P(PSTR("right"), false);
    }

    return true;
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    if (record->event.pressed) {
        counter++;
    }
    return true;
}
#endif

const rgblight_segment_t PROGMEM my_capslock_layer[] = RGBLIGHT_LAYER_SEGMENTS(
    {1, 2, HSV_RED},
    {7, 2, HSV_RED},
    {12, 2, HSV_RED},
    {17, 2, HSV_RED},
    {22, 2, HSV_RED},
    {26, 2, HSV_RED},
    {28, 1, HSV_RED},
    {30, 2, HSV_RED},
    {33, 2, HSV_RED},
    {39, 2, HSV_RED},
    {44, 2, HSV_RED},
    {49, 2, HSV_RED},
    {54, 2, HSV_RED},
    {58, 2, HSV_RED},
    {60, 1, HSV_RED},
    {62, 2, HSV_RED}
);
const rgblight_segment_t* const PROGMEM my_rgb_layers[] = RGBLIGHT_LAYERS_LIST(
    my_capslock_layer
);

void keyboard_post_init_user(void) {
    rgblight_layers = my_rgb_layers;
#ifdef OLED_ENABLE
    config.raw = eeconfig_read_user();
    counter = config.counter;
#endif
}

bool led_update_user(led_t led_state) {
    rgblight_set_layer_state(0, led_state.caps_lock);
    return true;
}
